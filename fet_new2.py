##alternative:
#read in as matrix, split into sub matrices based on clade, picking columns in that clade
#sum global from first matrix, sum clade specific stuff from clade matrices
#statistics is in python 3, run in anvio5env

#errors will likely be thrown if NA values in homolog matrix
#might get ValueError: cannot convert float NaN to integer with wrong names in meta file
import os
import sys
import pandas as pd
import scipy.stats as stats
import statsmodels.stats.multitest as mt

usage = """<input table> <each genome belongs to what clades> <output file name>"""
argv = sys.argv[1:]
if len(argv) == 3:
	input_table = argv.pop(0)
	clade_file = argv.pop(0)
	output_name = argv.pop(0)
else:
	sys.exit(usage)

clade_dict = {}
#read in clade file and store in dictionary
with open (clade_file,'r') as cf:
	for ln in cf:
		ln = ln.replace('\n','')
		name = ln.split()[0]
		clade = ln.split()[1]
		if clade not in clade_dict:
			clade_dict[clade] = []
		clade_dict[clade].append(name)

#read in data table (homolog matrix) generated by pyparanoid or others
df =pd.read_table(input_table,index_col=0)

#slice based on column names, sum totals
df_dict = {}
total_dict = {}
for c in clade_dict:
	seq = clade_dict[c]
	df_dict[c] = df.loc[:,seq]  #df.reindex(columns=seq)
	#sum all homologs
	total_dict[c] = df_dict[c].values.sum()
	df_dict[c]['rowTotal'] = df_dict[c].sum(axis=1)

#if only two items in clade, compare one with the other
#more than two will need to be compared one with everything but that one, not implemented
keys = list(df_dict.keys()) #python 2.x returns list, python 3.x does not 
df.append(pd.Series(name="OddsRatio"))
df.append(pd.Series(name="PvalueRaw"))

print("Performing Fisher's Exact Test...")
#Need to find way to speed up with multithreading and/or array operations
tempdf = df.copy()
if len(keys) == 2:
		for index, row in tempdf.iterrows():
			a = df_dict[keys[0]].at[index,'rowTotal']
			b = total_dict[keys[0]] - a
			c = df_dict[keys[1]].at[index,'rowTotal']
			d = total_dict[keys[1]] - c
			#default test is two-sided; differs from R unconditional vs conditional max likelihood estimate
			odds,pvalue = stats.fisher_exact([[a,c],[b,d]])
			df.loc[index,'OddsRatio'] = odds 
			df.loc[index,'PvalueRaw'] = pvalue
print("Performing multitest correction...")
significancetrue, bh_pvalues = mt.fdrcorrection(df['PvalueRaw'],alpha=0.05,method="indep",is_sorted=False)
df['PvalueBHcorrected'] = bh_pvalues
reject,bonferronipvals,als,ab = mt.multipletests(df['PvalueRaw'],alpha=0.05,method="bonferroni",is_sorted=False)
df['PvalueBonferronicorrected'] = bonferronipvals			
#Print out results
#May want to sort by pvalue eventually
#with open (output_name,'w') as out:
#	out.write(df.loc[:,['OddsRatio','PvalueRaw','PvalueBHcorrected']].to_string())
df.loc[:,['OddsRatio','PvalueRaw','PvalueBHcorrected','PvalueBonferronicorrected']].sort_values(by=['PvalueBHcorrected']).to_csv(output_name +".tbl",sep="\t")
	#out.write('{0}\t{1}\t{2}\t{3}\n'.format('Clade','Homolog','Odds Ratio','P value (uncorrected)'))
	#out.write('{0}\t{1}\t{2}\t{3}\n'.format(keys[0],index,odds,pvalue))



